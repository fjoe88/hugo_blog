---
title: '[R] How to write a custom lapply function that remember list names using closures
  and function factories'
author: zhoufang
date: '2020-08-20'
slug: r-how-to-write-a-custom-lapply-function-that-remember-list-names-using-closures-and-function-factories
categories:
  - R
tags:
  - R
  - Functional Programming
description: ~
featured_image: ~
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>One of my favorite as well as most used base function in R is <code>lapply</code>, where it allows one to apply a function over a <code>List</code> or a <code>Vector</code>, and return a list of the same length.</p>
<p>An example would be:</p>
<pre class="r"><code>num &lt;- list(0, 1, 2, 3)
add_one &lt;- function(x) x+1

#returns a new list same length as num but with each number element increased by one
num_add_one &lt;- lapply(num, add_one)</code></pre>
<p>Another variant of the <code>apply</code> family - <code>sapply</code>, works similarly to <code>lapply</code> except that the returned result will be simplified, using previous example</p>
<pre class="r"><code>#return a numeric vector instead of a list
num_add_one_simp &lt;- sapply(num, add_one)
num_add_one_simp</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<p>I see both <code>lapply</code> and <code>sapply</code> as vectorized version of writing up a for loop to iterate through an iterable such as a list or a vector, then return results iteratively to an empty list - which is an approach that is not encouraged for many reasons such as performance or readability. In Python this concept translates to language features such as <code>list comprehensions</code> that is very similar to <code>lapply</code>.</p>
<p>One of my frequent task is to also have access to the list’s name attribute inside the function call while using <code>lapply</code>, the reason being so that I can build custom conditionals inside my function depends on the name of each item from the list. Unfortunately, base R version of <code>lapply</code> does not allow such scenario to happen.</p>
<pre class="r"><code>names(num) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)

#returns NULL
list_of_names &lt;- lapply(num, function(x) names(x))</code></pre>
<p>While seeking helps on this issue, I encountered this stackoverflow question - <a href="https://stackoverflow.com/questions/9469504/access-and-preserve-list-names-in-lapply-function">“access-and-preserve-list-names-in-lapply-function”</a> and found other people having similar issue (far less than I though there would be), but none provided a solution to the actually problem therefore I decide to just write a custom <code>lapply</code> version that does just that, using functional programming features of closure and function factories.</p>
<pre class="r"><code>lapply_preserve_names &lt;- function(list, fun){
  lapply(seq_along(list), function(i){
    obj &lt;- list[i]
    names(obj) &lt;- names(list)[i]
    
    #instead of calling lapply on each item, calling on a length of 1 list with names attribute preserved
    fun(obj)
  })
}</code></pre>
<p>Now, instead of using <code>lapply</code>, simply use <code>lapply_preserve_names</code>, one caveat being that the first argument of function call becomes a list of length 1, and double bracket indexing is required to access the item itself , e.g. “x[[1]]”</p>
<pre class="r"><code>get_names &lt;- lapply_preserve_names(num, function(x) names(x))
get_names</code></pre>
<pre><code>## [[1]]
## [1] &quot;a&quot;
## 
## [[2]]
## [1] &quot;b&quot;
## 
## [[3]]
## [1] &quot;c&quot;
## 
## [[4]]
## [1] &quot;d&quot;</code></pre>
<p>Also notice that there can be work-around such as below example, however it requires one to use list indexing by name in order to access the content of each item.</p>
<pre class="r"><code>#use list index by name to access item itself while preserve names
foo &lt;- lapply(names(num), function(x) num[x])</code></pre>
